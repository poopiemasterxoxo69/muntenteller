<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Munten Teller" />
  <meta name="apple-touch-icon" href="icon.png" />
  <meta name="application-name" content="Munten Teller" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Munten Teller</title>
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" href="icon.png" type="image/png" />
  <link rel="apple-touch-icon" href="icon.png" />
  <style>
    :root {
      --bg: #0b1220;
      --panel: #0f1b33;
      --text: #e6edf7;
      --muted: #a7b4cb;
      --accent: #7aa2ff;
      --danger: #ff6b6b;
      --border: rgba(255, 255, 255, 0.12);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(122, 162, 255, 0.18), transparent 60%),
                  radial-gradient(900px 500px at 100% 30%, rgba(255, 107, 107, 0.10), transparent 60%),
                  var(--bg);
      color: var(--text);
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .sub {
      margin: 0;
      color: var(--muted);
      line-height: 1.35;
    }

    /* tabs */
    .tabs {
      display: flex;
      gap: 4px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 16px;
      overflow-x: auto;
    }

    .tab-btn {
      appearance: none;
      padding: 12px 16px;
      background: transparent;
      border: none;
      color: var(--muted);
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      letter-spacing: 0.2px;
      border-bottom: 2px solid transparent;
      transition: color 0.2s, border-color 0.2s;
      white-space: nowrap;
    }

    .tab-btn:hover {
      color: var(--text);
    }

    .tab-btn.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Barcode zoom modal */
    .barcode-zoom-modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }

    .barcode-zoom-modal.active {
      display: flex;
    }

    .barcode-zoom-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      max-width: 95vw;
      max-height: 95vh;
      overflow: auto;
    }

    .barcode-zoom-content canvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    .grid {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
    }

    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent 55%),
                  var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.30);
    }

    .card h2 {
      font-size: 14px;
      margin: 0 0 10px 0;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.2px;
      text-transform: uppercase;
    }

    .row { display: grid; gap: 10px; }
    .control {
      display: grid;
      gap: 6px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,0.12);
    }

    label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      color: var(--text);
      font-size: 13px;
    }

    label span {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }

    input[type="range"] { width: 100%; }
    input[type="file"] {
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.18);
      color: var(--muted);
    }

    .btns {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .progressWrap {
      display: grid;
      gap: 8px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,0.12);
    }

    .bar {
      position: relative;
      height: 10px;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.18);
    }

    .bar > .fill {
      position: absolute;
      inset: 0;
      width: 35%;
      background: linear-gradient(90deg, transparent, rgba(122, 162, 255, 0.55), transparent);
      transform: translateX(-60%);
      animation: slide 1.1s linear infinite;
    }

    @keyframes slide {
      0% { transform: translateX(-60%); }
      100% { transform: translateX(260%); }
    }

    .hidden { display: none !important; }

    button {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(122, 162, 255, 0.12);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    button.primary {
      background: linear-gradient(180deg, rgba(122, 162, 255, 0.30), rgba(122, 162, 255, 0.12));
      border-color: rgba(122, 162, 255, 0.35);
    }

    button.active {
      background: linear-gradient(180deg, rgba(56, 211, 159, 0.28), rgba(56, 211, 159, 0.10));
      border-color: rgba(56, 211, 159, 0.35);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .status {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.35;
    }

    .status strong { color: var(--text); }
    .status .err { color: var(--danger); }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--border);
    }

    .dot {
      width: 9px;
      height: 9px;
      border-radius: 99px;
      background: #888;
    }

    .dot.ok { background: #38d39f; }
    .dot.busy { background: #ffd166; }
    .dot.bad { background: #ff6b6b; }

    .canvasWrap {
      display: grid;
      gap: 12px;
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.20);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    /* coin calculator panel */
    .coinPanel {
      margin-top: 24px;
      padding: 14px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
    }
    .coinPanel h2 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.2px;
    }
    .coins {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .coin {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 50px;
      height: 50px;
      border: 1px solid var(--border);
      border-radius: 50%;
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      user-select: none;
      font-size: 13px;
      font-weight: 600;
      transition: background 0.2s;
    }
    .coin img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    .coin:hover {
      background: rgba(122,162,255,0.12);
    }
    .coin.total {
      cursor: default;
      border-color: transparent;
      background: transparent;
      font-size: 15px;
      margin-left: 20px;
    }
  </style>
</head>
<body>
  <!-- Barcode zoom modal -->
  <div id="barcodeZoomModal" class="barcode-zoom-modal">
    <div class="barcode-zoom-content">
      <canvas id="barcodeZoomCanvas"></canvas>
      <p style="margin-top: 12px; text-align: center; color: var(--muted); font-size: 12px;">Klik ergens om te sluiten</p>
    </div>
  </div>

  <div class="container">
    <header>
      <h1>Munten Teller (foto)v25</h1>
      <p class="sub">Upload een foto van je euromunten. De pagina telt alleen het <strong>aantal</strong> en tekent een cirkel om elk gevonden muntje.</p>
    </header>

    <div class="grid">
      <section class="card">
        <h2>Instellingen</h2>

        <div class="row">
          <div class="control">
            <label for="fileInput">Foto</label>
            <input id="fileInput" type="file" accept="image/*,.heic,.heif" />
          </div>

          <div class="control">
            <label for="whiteMode">Witte achtergrond modus <span>experimenteel</span></label>
            <input id="whiteMode" type="checkbox" />
          </div>

          <div class="btns">
            <button id="detectBtn" class="primary" disabled>Detecteer & tel</button>
            <button id="resetBtn" disabled>Reset</button>
            <button id="downloadBtn" disabled>Download resultaat</button>
          </div>

          <div id="progressWrap" class="progressWrap hidden">
            <div class="bar"><div class="fill"></div></div>
            <div class="hint">Bezig met tellen…</div>
          </div>

          <details class="control" style="padding: 0; overflow: hidden;">
            <summary style="list-style: none; cursor: pointer; padding: 10px;">Geavanceerde instellingen</summary>
            <div style="padding: 10px; display: grid; gap: 10px;">
              <div class="control">
                <label for="strictMode">Strenge detectie</label>
                <input id="strictMode" type="checkbox" />
              </div>

              <div class="control">
                <label for="targetRadius">Doel radius (strenge modus) <span id="targetRadiusVal">55</span></label>
                <input id="targetRadius" type="range" min="20" max="180" step="1" value="55" />
              </div>

              <div class="control">
                <label for="radiusTol">Radius tolerantie <span id="radiusTolVal">10</span></label>
                <input id="radiusTol" type="range" min="3" max="40" step="1" value="10" />
              </div>

              <div class="control">
                <label for="resizeMax">Max breedte voor analyse <span id="resizeMaxVal">650</span> px</label>
                <input id="resizeMax" type="range" min="400" max="900" step="10" value="650" />
              </div>

              <div class="control">
                <label for="blur">Blur <span id="blurVal">9</span></label>
                <input id="blur" type="range" min="1" max="31" step="2" value="9" />
              </div>

              <div class="control">
                <label for="dp">dp (Hough) <span id="dpVal">1.2</span></label>
                <input id="dp" type="range" min="10" max="30" step="1" value="12" />
              </div>

              <div class="control">
                <label for="minDist">Min afstand tussen munten <span id="minDistVal">30</span></label>
                <input id="minDist" type="range" min="5" max="140" step="1" value="30" />
              </div>

              <div class="control">
                <label for="param1">Edge threshold (param1) <span id="param1Val">140</span></label>
                <input id="param1" type="range" min="30" max="250" step="1" value="140" />
              </div>

              <div class="control">
                <label for="param2">Detectie gevoeligheid (param2) <span id="param2Val">38</span></label>
                <input id="param2" type="range" min="10" max="120" step="1" value="38" />
              </div>

              <div class="control">
                <label for="minRadius">Min radius <span id="minRadiusVal">35</span></label>
                <input id="minRadius" type="range" min="0" max="200" step="1" value="35" />
              </div>

              <div class="control">
                <label for="maxRadius">Max radius <span id="maxRadiusVal">160</span></label>
                <input id="maxRadius" type="range" min="0" max="400" step="1" value="160" />
              </div>
            </div>
          </details>

          <div class="status">
            <div class="pill"><span id="cvDot" class="dot"></span><span id="cvStatus">OpenCV laden…</span></div>
            <div style="margin-top:10px;">
              <strong>Gevonden munten:</strong> <span id="count">0</span>
            </div>
            <div id="msg" class="hint" style="margin-top:8px;"></div>
            <div id="techStats" class="hint" style="margin-top:8px;"></div>
          </div>
        </div>
      </section>

      <section class="card">
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 14px;">
          <h2 style="margin: 0; flex: 1;">Resultaat</h2>
          <button id="undoBtn" disabled style="padding: 8px 12px; font-size: 12px;">Undo</button>
          <button id="editBtn" disabled style="padding: 8px 12px; font-size: 12px;">Bewerken: uit</button>
          <button id="resetBtn" disabled style="padding: 8px 12px; font-size: 12px;">Reset</button>
        </div>
        <div class="canvasWrap">
          <canvas id="canvas"></canvas>
          <div class="hint">
            Tips: gebruik een foto met goed contrast, munten zo min mogelijk overlappend, en liefst zonder zware reflecties. Als er te veel/te weinig wordt gevonden: pas vooral <strong>param2</strong>, <strong>minDist</strong> en <strong>min/max radius</strong> aan.
          </div>
        </div>
      </section>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab-btn active" data-tab="coins">Handmatig tellen</button>
      <button class="tab-btn" data-tab="barcode-calc">Barcode Reader</button>
    </div>

    <!-- Tab: Handmatig tellen -->
    <div id="coins" class="tab-content active">
      <div class="coinPanel">
        <h2>Handmatige berekening</h2>
        <div class="coins">
          <div class="coin" data-value="0.05"><img src="img/5-cent.png" alt="5 cent"></div>
          <div class="coin" data-value="0.10"><img src="img/10-cent.png" alt="10 cent"></div>
          <div class="coin" data-value="0.20"><img src="img/20-cent.png" alt="20 cent"></div>
          <div class="coin" data-value="0.50"><img src="img/50-cent.png" alt="50 cent"></div>
          <div class="coin" data-value="1.00"><img src="img/1-euro.png" alt="1 euro"></div>
          <div class="coin" data-value="2.00"><img src="img/2-euro.png" alt="2 euro"></div>
          <div class="coin total">Totaal: €<span id="coinTotal">0.00</span></div>
        </div>
        <div style="margin-top: 20px;">
          <h3 style="font-size: 13px; color: var(--muted); margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 0.2px;">Barcode van detect</h3>
          <canvas id="coinBarcodeCanvas" style="width: 100%; border-radius: 14px; border: 1px solid var(--border); background: rgba(0,0,0,0.20); display: none;"></canvas>
        </div>
      </div>
    </div>

    <!-- Tab: Barcode Reader -->
    <div id="barcode-calc" class="tab-content">
      <div class="coinPanel">
        <h2>Barcode Rekenmachine</h2>
        <div class="control" style="margin-bottom: 12px;">
          <label for="barcodeCalcInput">Barcode invoeren</label>
          <input id="barcodeCalcInput" type="text" placeholder="Plak hier de barcode (aantal(x)waarde(y)ENTER)..." style="padding: 8px; border-radius: 10px; border: 1px solid var(--border); background: rgba(0,0,0,0.18); color: var(--text); width: 100%;" />
        </div>
        <div id="barcodeCalcResult" style="display: none; padding: 14px; background: rgba(0,0,0,0.12); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px;">
          <div style="display: flex; gap: 20px; align-items: flex-start;">
            <div style="flex: 1;">
              <p style="margin: 0 0 8px 0; color: var(--muted); font-size: 13px; text-transform: uppercase; letter-spacing: 0.2px;">Aantal munten</p>
              <p style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600;" id="calcCount">0</p>
              <p style="margin: 0 0 8px 0; color: var(--muted); font-size: 13px; text-transform: uppercase; letter-spacing: 0.2px;">Waarde per munt</p>
              <p style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600;" id="calcValue">€0.00</p>
              <p style="margin: 0 0 8px 0; color: var(--muted); font-size: 13px; text-transform: uppercase; letter-spacing: 0.2px;">Totaal bedrag</p>
              <p style="margin: 0; font-size: 24px; font-weight: 600; color: var(--accent);" id="calcTotal">€0.00</p>
            </div>
            <div style="flex: 0 0 140px; text-align: center;">
              <p style="margin: 0 0 10px 0; color: var(--muted); font-size: 13px; text-transform: uppercase; letter-spacing: 0.2px;">Munt</p>
              <img id="calcCoinImg" src="" alt="munt" style="max-width: 100%; height: auto; border-radius: 8px; border: 1px solid var(--border);" />
            </div>
          </div>
        </div>
        <div id="barcodeCalcError" style="display: none; padding: 10px; background: rgba(255, 107, 107, 0.12); border: 1px solid rgba(255, 107, 107, 0.5); border-radius: 8px; color: var(--danger); font-size: 13px;"></div>
        <div style="margin-top: 16px;">
          <h3 style="margin: 0 0 10px 0; font-size: 13px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.2px;">Gescande items</h3>
          <div id="barcodeList" style="display: grid; gap: 8px;">
            <div style="padding: 10px; background: rgba(0,0,0,0.12); border: 1px solid var(--border); border-radius: 8px; color: var(--muted); font-size: 12px; text-align: center;">Nog geen items gescand</div>
          </div>
        </div>
        <div id="barcodeListTotal" style="display: none; padding: 12px; background: rgba(122, 162, 255, 0.12); border: 1px solid rgba(122, 162, 255, 0.35); border-radius: 8px; margin-top: 10px; margin-bottom: 12px;">
          <p style="margin: 0; color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: 0.2px;">Totaal alle items</p>
          <p style="margin: 8px 0 0 0; font-size: 20px; font-weight: 600; color: var(--accent);" id="barcodeGrandTotal">€0.00</p>
        </div>
        <button id="clearBarcodeListBtn" style="width: 100%; padding: 10px; display: none; margin-bottom: 12px;">Lijst wissen</button>
        <div class="hint">Plak gescande barcodes in het formaat: aantal(15)waarde(1.00)ENTER</div>
      </div>

  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <script defer src="https://unpkg.com/heic2any/dist/heic2any.min.js" type="text/javascript"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js" type="text/javascript"></script>
  <script>
    // Polyfill for CanvasRenderingContext2D.roundRect for browsers that don't support it
    if (typeof CanvasRenderingContext2D !== 'undefined' && !CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (typeof r === 'number') {
          r = { tl: r, tr: r, br: r, bl: r };
        } else {
          r = Object.assign({ tl: 0, tr: 0, br: 0, bl: 0 }, r || {});
        }
        this.beginPath();
        this.moveTo(x + r.tl, y);
        this.lineTo(x + w - r.tr, y);
        this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        this.lineTo(x + w, y + h - r.br);
        this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        this.lineTo(x + r.bl, y + h);
        this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        this.lineTo(x, y + r.tl);
        this.quadraticCurveTo(x, y, x + r.tl, y);
        this.closePath();
      };
    }
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        // during local development we don't want the worker to cache files and
        // prevent live-server from refreshing; simply remove any existing workers
        const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        if (isLocal) {
          try {
            const regs = await navigator.serviceWorker.getRegistrations();
            regs.forEach((r) => r.unregister());
            console.log('Dev: service workers unregistered');
          } catch (e) {
            console.warn('Dev: error unregistering SW', e);
          }
          return;
        }
        // use a simple relative path (no leading ./) which is more forgiving on some servers
        navigator.serviceWorker.register('sw.js').catch(() => {});
      });
    }

    const els = {
      fileInput: document.getElementById('fileInput'),
      whiteMode: document.getElementById('whiteMode'),
      canvas: document.getElementById('canvas'),
      detectBtn: document.getElementById('detectBtn'),
      editBtn: document.getElementById('editBtn'),
      undoBtn: document.getElementById('undoBtn'),
      resetBtn: document.getElementById('resetBtn'),
      downloadBtn: document.getElementById('downloadBtn'),
      count: document.getElementById('count'),
      msg: document.getElementById('msg'),
      techStats: document.getElementById('techStats'),
      cvDot: document.getElementById('cvDot'),
      cvStatus: document.getElementById('cvStatus'),
      progressWrap: document.getElementById('progressWrap'),

      strictMode: document.getElementById('strictMode'),
      targetRadius: document.getElementById('targetRadius'),
      radiusTol: document.getElementById('radiusTol'),

      resizeMax: document.getElementById('resizeMax'),
      blur: document.getElementById('blur'),
      dp: document.getElementById('dp'),
      minDist: document.getElementById('minDist'),
      param1: document.getElementById('param1'),
      param2: document.getElementById('param2'),
      minRadius: document.getElementById('minRadius'),
      maxRadius: document.getElementById('maxRadius'),

      resizeMaxVal: document.getElementById('resizeMaxVal'),
      blurVal: document.getElementById('blurVal'),
      dpVal: document.getElementById('dpVal'),
      minDistVal: document.getElementById('minDistVal'),
      param1Val: document.getElementById('param1Val'),
      param2Val: document.getElementById('param2Val'),
      minRadiusVal: document.getElementById('minRadiusVal'),
      maxRadiusVal: document.getElementById('maxRadiusVal'),

      targetRadiusVal: document.getElementById('targetRadiusVal'),
      radiusTolVal: document.getElementById('radiusTolVal'),
    };

    const ctx = els.canvas.getContext('2d', { willReadFrequently: true });
    let sourceImg = new Image();
    let imageLoaded = false;
    let opencvReady = false;
    let busy = false;
    let editMode = false;
    let circlesState = [];
    let circlesHistory = [];
    let coinTotal = 0;

    function setCvStatus(kind, text) {
      els.cvDot.classList.remove('ok', 'busy', 'bad');
      if (kind === 'ok') els.cvDot.classList.add('ok');
      if (kind === 'busy') els.cvDot.classList.add('busy');
      if (kind === 'bad') els.cvDot.classList.add('bad');
      els.cvStatus.textContent = text;
    }

    function setBusy(isBusy) {
      busy = isBusy;
      els.detectBtn.disabled = !opencvReady || !imageLoaded || busy;
      els.resetBtn.disabled = !imageLoaded || busy;
      els.undoBtn.disabled = !imageLoaded || busy || circlesHistory.length === 0;
      els.downloadBtn.disabled = !imageLoaded || busy;
      if (els.progressWrap) {
        els.progressWrap.classList.toggle('hidden', !isBusy);
      }
      if (isBusy) setCvStatus('busy', 'Bezig met detecteren…');
      else setCvStatus(opencvReady ? 'ok' : 'busy', opencvReady ? 'OpenCV klaar' : 'OpenCV laden…');
    }

    function saveHistory() {
      circlesHistory.push(JSON.parse(JSON.stringify(circlesState)));
      els.undoBtn.disabled = false;
    }

    function undo() {
      if (circlesHistory.length === 0) return;
      circlesState = circlesHistory.pop();
      els.undoBtn.disabled = circlesHistory.length === 0;
      render();
    }

    function updateLabels() {
      els.resizeMaxVal.textContent = String(els.resizeMax.value);
      els.blurVal.textContent = String(els.blur.value);
      els.dpVal.textContent = (Number(els.dp.value) / 10).toFixed(1);
      els.minDistVal.textContent = String(els.minDist.value);
      els.param1Val.textContent = String(els.param1.value);
      els.param2Val.textContent = String(els.param2.value);
      els.minRadiusVal.textContent = String(els.minRadius.value);
      els.maxRadiusVal.textContent = String(els.maxRadius.value);
      if (els.targetRadiusVal && els.targetRadius) els.targetRadiusVal.textContent = String(els.targetRadius.value);
      if (els.radiusTolVal && els.radiusTol) els.radiusTolVal.textContent = String(els.radiusTol.value);
    }

    function resetOutput() {
      els.count.textContent = '0';
      els.msg.textContent = '';
      if (els.techStats) els.techStats.textContent = '';
      circlesState = [];
      circlesHistory = [];
      coinTotal = 0;
      els.undoBtn.disabled = true;
      const coinTotalEl = document.getElementById('coinTotal');
      if (coinTotalEl) coinTotalEl.textContent = '0.00';
      const barcodeCanvas = document.getElementById('coinBarcodeCanvas');
      if (barcodeCanvas) barcodeCanvas.style.display = 'none';
      if (imageLoaded) {
        drawImageToCanvas();
      } else {
        ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
      }
    }

    function clearCircles() {
      circlesState = [];
      render();
      els.msg.textContent = '';
      const barcodeCanvas = document.getElementById('coinBarcodeCanvas');
      if (barcodeCanvas) barcodeCanvas.style.display = 'none';
    }

    function render() {
      if (!imageLoaded) return;
      drawImageToCanvas();
      drawCircles(circlesState);
      els.count.textContent = String(circlesState.length);
    }

    function drawImageToCanvas() {
      const maxW = Math.max(200, Number(els.resizeMax && els.resizeMax.value ? els.resizeMax.value : 650));
      const scale = Math.min(1, maxW / sourceImg.naturalWidth);
      const w = Math.max(1, Math.round(sourceImg.naturalWidth * scale));
      const h = Math.max(1, Math.round(sourceImg.naturalHeight * scale));
      els.canvas.width = w;
      els.canvas.height = h;
      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(sourceImg, 0, 0, w, h);
    }

    function getParams() {
      const blurK = Number(els.blur.value);
      const dp = Number(els.dp.value) / 10;
      const minDist = Number(els.minDist.value);
      const param1 = Number(els.param1.value);
      const param2 = Number(els.param2.value);
      const minRadius = Number(els.minRadius.value);
      const maxRadius = Number(els.maxRadius.value);

      return { blurK, dp, minDist, param1, param2, minRadius, maxRadius };
    }

    function drawCircles(circles) {
      if (!circles || circles.length === 0) return;

      ctx.save();
      ctx.lineWidth = Math.max(2, Math.round(Math.min(els.canvas.width, els.canvas.height) / 350));
      ctx.strokeStyle = 'rgba(255, 230, 109, 0.95)';
      ctx.fillStyle = 'rgba(122, 162, 255, 0.95)';

      const fontSize = Math.max(12, Math.round(Math.min(els.canvas.width, els.canvas.height) / 40));
      ctx.font = `600 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = 'middle';

      for (let i = 0; i < circles.length; i++) {
        const c = circles[i];
        const n = i + 1;
        // use a different color for user-added circles
        if (c.manual) {
          ctx.strokeStyle = 'rgba(122, 162, 255, 0.95)';
          ctx.fillStyle = 'rgba(122, 162, 255, 0.40)';
        } else {
          ctx.strokeStyle = 'rgba(255, 230, 109, 0.95)';
          ctx.fillStyle = 'rgba(122, 162, 255, 0.95)';
        }
        ctx.lineWidth = Math.max(2, Math.round(Math.min(els.canvas.width, els.canvas.height) / 350));
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(c.x, c.y, Math.max(2, ctx.lineWidth + 1), 0, Math.PI * 2);
        ctx.fill();

        const label = String(n);
        const padX = Math.max(6, Math.round(fontSize * 0.35));
        const padY = Math.max(4, Math.round(fontSize * 0.22));
        const metrics = ctx.measureText(label);
        const boxW = metrics.width + padX * 2;
        const boxH = fontSize + padY * 2;
        const bx = Math.max(0, Math.min(els.canvas.width - boxW, c.x - boxW / 2));
        const by = Math.max(0, Math.min(els.canvas.height - boxH, c.y - boxH / 2));

        ctx.fillStyle = 'rgba(11, 18, 32, 0.80)';
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.22)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(bx, by, boxW, boxH, Math.max(6, Math.round(boxH / 3)));
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
        ctx.fillText(label, bx + padX, by + boxH / 2);

        // restore default styles for next iteration
        ctx.strokeStyle = 'rgba(255, 230, 109, 0.95)';
        ctx.fillStyle = 'rgba(122, 162, 255, 0.95)';
        ctx.lineWidth = Math.max(2, Math.round(Math.min(els.canvas.width, els.canvas.height) / 350));
      }

      ctx.restore();
    }

    function setEditMode(on) {
      editMode = !!on;
      if (els.editBtn) {
        els.editBtn.textContent = editMode ? 'Bewerken: aan' : 'Bewerken: uit';
        els.editBtn.classList.toggle('active', editMode);
      }
      els.msg.textContent = editMode ? 'Bewerken aan: tik op een cirkel om te verwijderen. Tik op lege plek om toe te voegen (handmatig toegevoegde cirkels verschijnen blauw).' : '';
    }

    function getCanvasPointFromEvent(ev) {
      const rect = els.canvas.getBoundingClientRect();
      const x = (ev.clientX - rect.left) * (els.canvas.width / rect.width);
      const y = (ev.clientY - rect.top) * (els.canvas.height / rect.height);
      return { x, y };
    }

    function medianRadius() {
      if (!circlesState || circlesState.length === 0) return Math.max(20, Number(els.minRadius && els.minRadius.value ? els.minRadius.value : 30));
      const rs = circlesState.map((c) => c.r).filter((r) => Number.isFinite(r)).sort((a, b) => a - b);
      return rs[Math.floor(rs.length / 2)] || Math.max(20, Number(els.minRadius && els.minRadius.value ? els.minRadius.value : 30));
    }

    function findHitCircleIndex(pt) {
      const tol = Math.max(10, Math.min(22, medianRadius() * 0.25));
      for (let i = 0; i < circlesState.length; i++) {
        const c = circlesState[i];
        const dx = pt.x - c.x;
        const dy = pt.y - c.y;
        const d = Math.hypot(dx, dy);
        if (d <= c.r + tol) return i;
      }
      return -1;
    }

    function nextFrame() {
      return new Promise((resolve) => requestAnimationFrame(() => resolve()))
    }

    function dedupeCircles(circles) {
      if (!circles || circles.length <= 1) return circles || [];
      const sorted = [...circles].sort((a, b) => b.r - a.r);
      const kept = [];

      for (const c of sorted) {
        let ok = true;
        for (const k of kept) {
          const dx = c.x - k.x;
          const dy = c.y - k.y;
          const d = Math.hypot(dx, dy);
          const rMin = Math.min(c.r, k.r);
          const rMax = Math.max(c.r, k.r);
          const similarSize = (rMax / Math.max(1, rMin)) < 1.25;
          const veryClose = d < (0.35 * rMin);
          if (similarSize && veryClose) {
            // if the incoming circle was manual, propagate that flag to the kept circle
            if (c.manual) k.manual = true;
            ok = false;
            break;
          }
        }
        if (ok) kept.push(c);
      }

      return kept.sort((a, b) => (a.y - b.y) || (a.x - b.x));
    }

    function edgeRingFilter(circles, edges, opts) {
      if (!circles || circles.length === 0) return [];
      const width = edges.cols;
      const height = edges.rows;

      const sampleCount = opts && opts.sampleCount ? opts.sampleCount : 44;
      const minRatio = opts && opts.minRatio ? opts.minRatio : 0.18;
      const minHits = opts && opts.minHits ? opts.minHits : 8;
      const ringInner = opts && opts.ringInner ? opts.ringInner : 0.92;
      const ringOuter = opts && opts.ringOuter ? opts.ringOuter : 1.06;

      function isEdgeAt(x, y) {
        const xi = x | 0;
        const yi = y | 0;
        if (xi < 0 || yi < 0 || xi >= width || yi >= height) return false;
        return edges.data[yi * width + xi] > 0;
      }

      const out = [];
      for (const c of circles) {
        const cx = c.x;
        const cy = c.y;
        const r = c.r;

        if (!Number.isFinite(cx) || !Number.isFinite(cy) || !Number.isFinite(r) || r <= 0) continue;
        if (r > Math.min(width, height) * 0.49) continue;

        let hits = 0;
        for (let i = 0; i < sampleCount; i++) {
          const a = (i / sampleCount) * Math.PI * 2;
          const ca = Math.cos(a);
          const sa = Math.sin(a);

          const x1 = cx + ca * r * ringInner;
          const y1 = cy + sa * r * ringInner;
          const x2 = cx + ca * r * ringOuter;
          const y2 = cy + sa * r * ringOuter;

          if (isEdgeAt(x1, y1) || isEdgeAt(x2, y2)) hits++;
        }

        const ratio = hits / sampleCount;
        if (hits >= minHits && ratio >= minRatio) {
          out.push(c);
        }
      }

      return out;
    }

    function buildNonWhiteMask(srcRgba) {
      const rgb = new cv.Mat();
      cv.cvtColor(srcRgba, rgb, cv.COLOR_RGBA2RGB);

      const hsv = new cv.Mat();
      cv.cvtColor(rgb, hsv, cv.COLOR_RGB2HSV);

      const channels = new cv.MatVector();
      cv.split(hsv, channels);
      const s = channels.get(1);
      const v = channels.get(2);

      const sMask = new cv.Mat();
      const vMask = new cv.Mat();
      cv.threshold(s, sMask, 35, 255, cv.THRESH_BINARY);
      cv.threshold(v, vMask, 235, 255, cv.THRESH_BINARY_INV);

      const mask = new cv.Mat();
      cv.bitwise_or(sMask, vMask, mask);

      const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5, 5));
      cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
      cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);

      rgb.delete();
      hsv.delete();
      s.delete();
      v.delete();
      channels.delete();
      sMask.delete();
      vMask.delete();
      kernel.delete();

      return mask;
    }

    function maskOverlapFilter(circles, mask) {
      if (!circles || circles.length === 0) return [];
      if (!mask || mask.empty()) return circles;

      const w = mask.cols;
      const h = mask.rows;
      const data = mask.data;

      function sampleMask(x, y) {
        const xi = x | 0;
        const yi = y | 0;
        if (xi < 0 || yi < 0 || xi >= w || yi >= h) return 0;
        return data[yi * w + xi] > 0 ? 1 : 0;
      }

      const out = [];
      for (const c of circles) {
        const samples = 40;
        let hits = 0;
        for (let i = 0; i < samples; i++) {
          const a = (i / samples) * Math.PI * 2;
          const rx = c.x + Math.cos(a) * c.r * 0.55;
          const ry = c.y + Math.sin(a) * c.r * 0.55;
          hits += sampleMask(rx, ry);
        }
        const ratio = hits / samples;
        if (ratio >= 0.05) out.push(c);
      }
      return out;
    }

    function findContourCircles(gray, minRadius, maxRadius) {
      const bin = new cv.Mat();
      cv.adaptiveThreshold(gray, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 31, 2);

      const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
      const morphed = new cv.Mat();
      cv.morphologyEx(bin, morphed, cv.MORPH_OPEN, kernel);
      cv.morphologyEx(morphed, morphed, cv.MORPH_CLOSE, kernel);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      const circles = [];
      const rMin = Math.max(0, minRadius);
      const rMax = maxRadius > 0 ? maxRadius : Math.min(gray.cols, gray.rows);

      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        const perim = cv.arcLength(cnt, true);
        if (!Number.isFinite(area) || !Number.isFinite(perim) || perim <= 0) {
          cnt.delete();
          continue;
        }

        const circularity = (4 * Math.PI * area) / (perim * perim);
        if (circularity < 0.62) {
          cnt.delete();
          continue;
        }

        const circle = cv.minEnclosingCircle(cnt);
        const x = circle.center.x;
        const y = circle.center.y;
        const r = circle.radius;

        if (r >= rMin && r <= rMax && Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(r)) {
          circles.push({ x, y, r });
        }
        cnt.delete();
      }

      bin.delete();
      kernel.delete();
      morphed.delete();
      contours.delete();
      hierarchy.delete();

      return circles;
    }

    function mergeCircles(houghCircles, contourCircles) {
      // FIXED: Changed from strict consensus to union (OR) logic
      // This allows circles found by EITHER method to be counted
      if (!houghCircles) houghCircles = [];
      if (!contourCircles) contourCircles = [];
      
      if (houghCircles.length === 0 && contourCircles.length === 0) return [];
      
      // Start with all Hough circles
      const merged = [...houghCircles];
      
      // For each contour circle, check if it's already represented in merged
      for (const c of contourCircles) {
        let found = false;
        for (const m of merged) {
          const dx = c.x - m.x;
          const dy = c.y - m.y;
          const d = Math.hypot(dx, dy);
          const rMin = Math.min(c.r, m.r);
          const rMax = Math.max(c.r, m.r);
          const rRatio = rMax / Math.max(1, rMin);
          
          // If circles are close and similar size, consider them the same
          if (d <= Math.max(6, 0.22 * rMin) && rRatio <= 1.35) {
            found = true;
            break;
          }
        }
        // Add contour circle if it wasn't already found
        if (!found) {
          merged.push(c);
        }
      }
      
      return dedupeCircles(merged);
    }

    async function detectCoins() {
      if (!opencvReady || !imageLoaded || busy) return;
      setBusy(true);
      resetOutput();
      setEditMode(false);

      await nextFrame();

      const strictOn = !!(els.strictMode && els.strictMode.checked);
      const { blurK, dp, minDist, param1, param2, minRadius, maxRadius } = getParams();

      const targetR = Math.max(5, Number(els.targetRadius && els.targetRadius.value ? els.targetRadius.value : 55));
      const tolR = Math.max(0, Number(els.radiusTol && els.radiusTol.value ? els.radiusTol.value : 10));
      const strictMinR = Math.max(0, Math.round(targetR - tolR));
      const strictMaxR = Math.max(strictMinR + 1, Math.round(targetR + tolR));

      const useMinRadius = strictOn ? strictMinR : minRadius;
      const useMaxRadius = strictOn ? strictMaxR : maxRadius;
      const useParam2 = strictOn ? Math.max(param2, 55) : param2;
      const useMinDist = strictOn ? Math.max(minDist, Math.round(targetR * 1.35)) : minDist;
      const useParam1 = strictOn ? Math.max(param1, 150) : param1;

      if (useMaxRadius > 0 && useMinRadius > useMaxRadius) {
        els.msg.innerHTML = '<span class="err">Min radius is groter dan max radius.</span>';
        setBusy(false);
        return;
      }

      try {
        const src = cv.imread(els.canvas);
        const gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        const blurred = new cv.Mat();
        const k = Math.max(1, blurK | 1);
        cv.GaussianBlur(gray, blurred, new cv.Size(k, k), 0, 0, cv.BORDER_DEFAULT);

        const edges = new cv.Mat();
        const t2 = Math.max(40, Math.min(260, param1));
        const t1 = Math.max(20, Math.round(t2 * 0.5));
        cv.Canny(blurred, edges, t1, t2);

        const circles = new cv.Mat();
        cv.HoughCircles(
          blurred,
          circles,
          cv.HOUGH_GRADIENT,
          dp,
          useMinDist,
          useParam1,
          useParam2,
          useMinRadius,
          useMaxRadius
        );

        const stats = {
          strict: strictOn,
          houghRaw: 0,
          afterEdge: 0,
          afterDedupe1: 0,
          contour: 0,
          merged: 0,
          final: 0,
        };

        let out = [];
        if (!circles.empty()) {
          for (let i = 0; i < circles.cols; i++) {
            const x = circles.data32F[i * 3];
            const y = circles.data32F[i * 3 + 1];
            const r = circles.data32F[i * 3 + 2];
            if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(r)) {
              out.push({ x, y, r });
            }
          }
        }

        stats.houghRaw = out.length;

        out = out.filter((c) => c.r >= Math.max(0, useMinRadius));
        out = edgeRingFilter(out, edges, strictOn ? {
          sampleCount: 56,
          minRatio: 0.22,
          minHits: 10,
        } : {
          sampleCount: 48,
          minRatio: 0.17,
          minHits: 8,
        });

        stats.afterEdge = out.length;
        out = dedupeCircles(out);

        stats.afterDedupe1 = out.length;

        // FIXED: Use union (merge) instead of strict consensus
        let contourOut = [];
        if (!strictOn) {
          contourOut = dedupeCircles(findContourCircles(blurred, minRadius, maxRadius));
          stats.contour = contourOut.length;
          
          // Changed: Always merge results (union) instead of consensus
          const mergedOut = mergeCircles(out, contourOut);
          stats.merged = mergedOut.length;
          out = mergedOut;
        } else {
          // strictOn: normally only Hough is used; if whiteMode is enabled, also include contours (union)
          if (els.whiteMode && els.whiteMode.checked) {
            contourOut = dedupeCircles(findContourCircles(blurred, useMinRadius, useMaxRadius));
            stats.contour = contourOut.length;
            const mergedOut = mergeCircles(out, contourOut);
            stats.merged = mergedOut.length;
            out = mergedOut;
          }
        }

        // If whiteMode is checked, prefer masking to remove non-white areas (helps remove false positives)
        if (els.whiteMode && els.whiteMode.checked) {
          const mask = buildNonWhiteMask(src);
          out = maskOverlapFilter(out, mask);
          mask.delete();
        }

        out = dedupeCircles(out);

        stats.final = out.length;

        src.delete();
        gray.delete();
        blurred.delete();
        edges.delete();
        circles.delete();

        circlesState = out;
        render();
        if (els.techStats) {
          if (strictOn) {
            els.techStats.textContent = `Techniek: Streng (Hough). Hough: ${stats.houghRaw} → edge: ${stats.afterEdge} → dedupe: ${stats.afterDedupe1} → eind: ${stats.final}`;
          } else {
            els.techStats.textContent = `Techniek: Hough + Contour (UNION). Hough: ${stats.houghRaw} → edge: ${stats.afterEdge} → dedupe: ${stats.afterDedupe1} | contour: ${stats.contour} → merged: ${stats.merged} → eind: ${stats.final}`;
          }
        }
        if (out.length === 0) {
          els.msg.textContent = 'Geen munten gevonden met deze instellingen. Probeer param2 lager, of radius/minDist aanpassen.';
        } else {
          els.msg.textContent = 'Klaar.';
        }
      } catch (e) {
        els.msg.innerHTML = '<span class="err">Fout tijdens detectie: </span>' + String(e && e.message ? e.message : e);
      } finally {
        setBusy(false);
      }
    }

    function downloadCanvas() {
      if (!imageLoaded) return;
      const link = document.createElement('a');
      link.download = 'munten-resultaat.png';
      link.href = els.canvas.toDataURL('image/png');
      link.click();
    }

    function isHeicFile(file) {
      const name = String(file && file.name ? file.name : '').toLowerCase();
      const type = String(file && file.type ? file.type : '').toLowerCase();
      return type.includes('heic') || type.includes('heif') || name.endsWith('.heic') || name.endsWith('.heif');
    }

    async function toDisplayableBlob(file) {
      if (!file) return null;

      if (!isHeicFile(file)) {
        return file;
      }

      if (typeof heic2any !== 'function') {
        throw new Error('HEIC wordt nog niet ondersteund (converter kon niet laden).');
      }

      const out = await heic2any({
        blob: file,
        toType: 'image/jpeg',
        quality: 0.92,
      });

      if (out instanceof Blob) return out;
      if (Array.isArray(out) && out[0] instanceof Blob) return out[0];
      throw new Error('HEIC conversie mislukt.');
    }

    async function setImageFromFile(file) {
      if (!file) return;

      setBusy(true);
      els.msg.textContent = '';
      imageLoaded = false;
      els.detectBtn.disabled = true;
      els.resetBtn.disabled = true;
      els.undoBtn.disabled = true;
      els.downloadBtn.disabled = true;

      let url = '';
      try {
        const blob = await toDisplayableBlob(file);
        url = URL.createObjectURL(blob);
        sourceImg = new Image();
        sourceImg.onload = () => {
          URL.revokeObjectURL(url);
          imageLoaded = true;
          drawImageToCanvas();
          resetOutput();
          els.detectBtn.disabled = !opencvReady;
          if (els.editBtn) els.editBtn.disabled = false;
          els.resetBtn.disabled = false;
          els.downloadBtn.disabled = false;
          setBusy(false);
        };
        sourceImg.onerror = () => {
          URL.revokeObjectURL(url);
          imageLoaded = false;
          els.msg.innerHTML = '<span class="err">Kon deze afbeelding niet laden.</span> Als dit een HEIC foto is: probeer opnieuw na een paar seconden (converter laden), of zet je iPhone camera op "Meest compatibel".';
          setBusy(false);
        };
        sourceImg.src = url;
      } catch (e) {
        if (url) URL.revokeObjectURL(url);
        imageLoaded = false;
        els.msg.innerHTML = '<span class="err">Upload probleem: </span>' + String(e && e.message ? e.message : e);
        setBusy(false);
      }
    }

    function wireEvents() {
      updateLabels();
      for (const id of ['strictMode','targetRadius','radiusTol','resizeMax','blur','dp','minDist','param1','param2','minRadius','maxRadius']) {
        els[id].addEventListener('input', () => {
          updateLabels();
          if (imageLoaded) {
            render();
          }
        });
      }

      els.fileInput.addEventListener('change', (ev) => {
        const file = ev.target.files && ev.target.files[0];
        setImageFromFile(file);
      });

      els.detectBtn.addEventListener('click', detectCoins);
      if (els.editBtn) {
        els.editBtn.addEventListener('click', () => {
          if (!imageLoaded || busy) return;
          setEditMode(!editMode);
        });
      }
      els.resetBtn.addEventListener('click', resetOutput);
      if (els.undoBtn) {
        els.undoBtn.addEventListener('click', undo);
      }
      els.downloadBtn.addEventListener('click', downloadCanvas);

      els.canvas.addEventListener('pointerdown', (ev) => {
        if (!editMode || busy || !imageLoaded) return;
        ev.preventDefault();
        saveHistory();
        const pt = getCanvasPointFromEvent(ev);
        const idx = findHitCircleIndex(pt);
        if (idx >= 0) {
          circlesState.splice(idx, 1);
        } else {
          const r = medianRadius();
          circlesState.push({ x: pt.x, y: pt.y, r, manual: true });
        }
        circlesState = dedupeCircles(circlesState);
        render();
      }, { passive: false });

      // coin calculator listeners
      {
        const coinEls = document.querySelectorAll('.coin[data-value]');
        coinEls.forEach((el) => {
          el.addEventListener('click', () => {
            const v = parseFloat(el.dataset.value);
            if (Number.isFinite(v)) {
              coinTotal += v;
              document.getElementById('coinTotal').textContent = coinTotal.toFixed(2);
              
              // Generate barcode: aantal(x)waarde(y)ENTER
              const barcodeCanvas = document.getElementById('coinBarcodeCanvas');
              const count = circlesState.length;
              const barcodeValue = `aantal(${count})waarde(${v.toFixed(2)})ENTER`;
              
              if (barcodeCanvas && typeof JsBarcode !== 'undefined') {
                barcodeCanvas.style.display = 'block';
                try {
                  JsBarcode(barcodeCanvas, barcodeValue, {
                    format: 'CODE128',
                    width: 2,
                    height: 60,
                    displayValue: true
                  });
                } catch (e) {
                  console.warn('Barcode fout:', e);
                }
              }
            }
          });
        });
      }
    }

    // Barcode calculator listener
    const barcodeCalcInput = document.getElementById('barcodeCalcInput');
    const barcodeCalcError = document.getElementById('barcodeCalcError');
    const barcodeList = document.getElementById('barcodeList');
    const barcodeListTotal = document.getElementById('barcodeListTotal');
    const clearBarcodeListBtn = document.getElementById('clearBarcodeListBtn');
    
    let scannedItems = [];
    
    const coinImages = {
      '0.05': 'img/5-cent.png',
      '0.10': 'img/10-cent.png',
      '0.20': 'img/20-cent.png',
      '0.50': 'img/50-cent.png',
      '1.00': 'img/1-euro.png',
      '2.00': 'img/2-euro.png'
    };

    function updateBarcodeList() {
      if (scannedItems.length === 0) {
        barcodeList.innerHTML = '<div style="padding: 10px; background: rgba(0,0,0,0.12); border: 1px solid var(--border); border-radius: 8px; color: var(--muted); font-size: 12px; text-align: center;">Nog geen items gescand</div>';
        barcodeListTotal.style.display = 'none';
        clearBarcodeListBtn.style.display = 'none';
        return;
      }

      let grandTotal = 0;
      barcodeList.innerHTML = scannedItems.map((item, idx) => {
        const itemTotal = item.aantal * item.waarde;
        grandTotal += itemTotal;
        const waardeStr = item.waarde.toFixed(2);
        const coinImg = coinImages[waardeStr];
        return `
          <div style="padding: 10px; background: rgba(0,0,0,0.12); border: 1px solid var(--border); border-radius: 8px; display: flex; justify-content: space-between; align-items: center; gap: 12px;">
            <img src="${coinImg || ''}" alt="munt" style="width: 50px; height: 50px; border-radius: 50%; border: 1px solid var(--border); flex-shrink: 0;" />
            <div style="flex: 1;">
              <p style="margin: 0; font-size: 14px; font-weight: 600;">${item.aantal} × €${item.waarde.toFixed(2)} = <span style="color: var(--accent);">€${itemTotal.toFixed(2)}</span></p>
            </div>
            <button onclick="document.dispatchEvent(new CustomEvent('removeBarcode', {detail: ${idx}}))" style="padding: 6px 10px; font-size: 12px; flex-shrink: 0;">Verwijder</button>
          </div>
        `;
      }).join('');

      document.getElementById('barcodeGrandTotal').textContent = '€' + grandTotal.toFixed(2);
      barcodeListTotal.style.display = 'block';
      clearBarcodeListBtn.style.display = 'block';
    }

    if (barcodeCalcInput) {
      barcodeCalcInput.addEventListener('input', () => {
        const input = barcodeCalcInput.value.trim();
        barcodeCalcError.style.display = 'none';

        // Check if input contains ENTER at the end
        if (!input.includes('ENTER')) return;

        // Parse: aantal(x)waarde(y)ENTER
        const regex = /aantal\((\d+)\)waarde\(([\d.]+)\)ENTER/;
        const match = input.match(regex);

        if (!match) {
          barcodeCalcError.style.display = 'block';
          barcodeCalcError.textContent = 'Ongeldig formaat. Verwacht: aantal(x)waarde(y)ENTER';
          return;
        }

        const aantal = parseInt(match[1], 10);
        const waarde = parseFloat(match[2]);

        if (!Number.isFinite(aantal) || !Number.isFinite(waarde) || aantal <= 0 || waarde <= 0) {
          barcodeCalcError.style.display = 'block';
          barcodeCalcError.textContent = 'Ongeldig aantal of waarde';
          return;
        }

        // Voeg toe aan list
        scannedItems.push({ aantal, waarde });
        updateBarcodeList();
        barcodeCalcInput.value = '';
      });
    }

    // Remove item from list
    document.addEventListener('removeBarcode', (e) => {
      scannedItems.splice(e.detail, 1);
      updateBarcodeList();
    });

    // Clear list button
    if (clearBarcodeListBtn) {
      clearBarcodeListBtn.addEventListener('click', () => {
        scannedItems = [];
        updateBarcodeList();
      });
    }

    // Barcode zoom functionality
    const coinBarcodeCanvas = document.getElementById('coinBarcodeCanvas');
    const barcodeZoomModal = document.getElementById('barcodeZoomModal');
    const barcodeZoomCanvas = document.getElementById('barcodeZoomCanvas');

    if (coinBarcodeCanvas) {
      coinBarcodeCanvas.addEventListener('click', () => {
        if (coinBarcodeCanvas.style.display === 'block') {
          // Copy the barcode to zoom canvas
          const dataUrl = coinBarcodeCanvas.toDataURL('image/png');
          const img = new Image();
          img.onload = () => {
            barcodeZoomCanvas.width = img.width;
            barcodeZoomCanvas.height = img.height;
            const zoomCtx = barcodeZoomCanvas.getContext('2d');
            zoomCtx.drawImage(img, 0, 0);
            barcodeZoomModal.classList.add('active');
          };
          img.src = dataUrl;
        }
      });
    }

    // Close zoom modal
    barcodeZoomModal.addEventListener('click', (e) => {
      if (e.target === barcodeZoomModal) {
        barcodeZoomModal.classList.remove('active');
      }
    });

    // Close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        barcodeZoomModal.classList.remove('active');
      }
    });

    // Tab switching
    document.querySelectorAll('.tab-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        const tabName = btn.getAttribute('data-tab');
        
        // Deactivate all tabs and buttons
        document.querySelectorAll('.tab-btn').forEach((b) => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach((t) => t.classList.remove('active'));
        
        // Activate selected tab and button
        btn.classList.add('active');
        document.getElementById(tabName).classList.add('active');
      });
    });

    wireEvents();

    (function waitForOpenCV() {
      const start = Date.now();
      const maxWaitMs = 30000;

      function tick() {
        const elapsed = Date.now() - start;
        if (typeof cv !== 'undefined' && cv) {
          if (typeof cv.imread === 'function' && typeof cv.Mat === 'function') {
            opencvReady = true;
            setCvStatus('ok', 'OpenCV klaar');
            els.detectBtn.disabled = !imageLoaded || busy;
            return;
          }
          if (typeof cv.onRuntimeInitialized === 'function') {
            const prev = cv.onRuntimeInitialized;
            cv.onRuntimeInitialized = () => {
              try { prev(); } catch (_) {}
              opencvReady = true;
              setCvStatus('ok', 'OpenCV klaar');
              els.detectBtn.disabled = !imageLoaded || busy;
            };
          }
        }
        if (elapsed > maxWaitMs) {
          setCvStatus('bad', 'OpenCV laden mislukt');
          els.msg.innerHTML = '<span class="err">OpenCV.js kon niet geladen worden.</span> Controleer je internetverbinding of blokkers (adblock/firewall).';
          return;
        }
        setCvStatus('busy', 'OpenCV laden…');
        setTimeout(tick, 150);
      }

      tick();
    })();
  </script>
</body>
</html>