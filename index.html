
<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Munten Teller</title>
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" href="icon.svg" type="image/svg+xml" />
  <style>
    :root {
      --bg: #0b1220;
      --panel: #0f1b33;
      --text: #e6edf7;
      --muted: #a7b4cb;
      --accent: #7aa2ff;
      --danger: #ff6b6b;
      --border: rgba(255, 255, 255, 0.12);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(122, 162, 255, 0.18), transparent 60%),
                  radial-gradient(900px 500px at 100% 30%, rgba(255, 107, 107, 0.10), transparent 60%),
                  var(--bg);
      color: var(--text);
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .sub {
      margin: 0;
      color: var(--muted);
      line-height: 1.35;
    }

    .grid {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
    }

    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), transparent 55%),
                  var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.30);
    }

    .card h2 {
      font-size: 14px;
      margin: 0 0 10px 0;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.2px;
      text-transform: uppercase;
    }

    .row { display: grid; gap: 10px; }
    .control {
      display: grid;
      gap: 6px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,0.12);
    }

    label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      color: var(--text);
      font-size: 13px;
    }

    label span {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }

    input[type="range"] { width: 100%; }
    input[type="file"] {
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.18);
      color: var(--muted);
    }

    .btns {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .progressWrap {
      display: grid;
      gap: 8px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(0,0,0,0.12);
    }

    .bar {
      position: relative;
      height: 10px;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.18);
    }

    .bar > .fill {
      position: absolute;
      inset: 0;
      width: 35%;
      background: linear-gradient(90deg, transparent, rgba(122, 162, 255, 0.55), transparent);
      transform: translateX(-60%);
      animation: slide 1.1s linear infinite;
    }

    @keyframes slide {
      0% { transform: translateX(-60%); }
      100% { transform: translateX(260%); }
    }

    .hidden { display: none !important; }

    button {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(122, 162, 255, 0.12);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    button.primary {
      background: linear-gradient(180deg, rgba(122, 162, 255, 0.30), rgba(122, 162, 255, 0.12));
      border-color: rgba(122, 162, 255, 0.35);
    }

    button.active {
      background: linear-gradient(180deg, rgba(56, 211, 159, 0.28), rgba(56, 211, 159, 0.10));
      border-color: rgba(56, 211, 159, 0.35);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .status {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.35;
    }

    .status strong { color: var(--text); }
    .status .err { color: var(--danger); }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--border);
    }

    .dot {
      width: 9px;
      height: 9px;
      border-radius: 99px;
      background: #888;
    }

    .dot.ok { background: #38d39f; }
    .dot.busy { background: #ffd166; }
    .dot.bad { background: #ff6b6b; }

    .canvasWrap {
      display: grid;
      gap: 12px;
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.20);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Munten Teller (foto)v16</h1>
      <p class="sub">Upload een foto van je euromunten. De pagina telt alleen het <strong>aantal</strong> en tekent een cirkel om elk gevonden muntje.</p>
    </header>

    <div class="grid">
      <section class="card">
        <h2>Instellingen</h2>

        <div class="row">
          <div class="control">
            <label for="fileInput">Foto</label>
            <input id="fileInput" type="file" accept="image/*,.heic,.heif" />
          </div>

          <div class="control">
            <label for="whiteMode">Witte achtergrond modus <span>experimenteel</span></label>
            <input id="whiteMode" type="checkbox" />
          </div>

          <div class="btns">
            <button id="detectBtn" class="primary" disabled>Detecteer & tel</button>
            <button id="editBtn" disabled>Bewerken: uit</button>
            <button id="resetBtn" disabled>Reset</button>
            <button id="downloadBtn" disabled>Download resultaat</button>
          </div>

          <div id="progressWrap" class="progressWrap hidden">
            <div class="bar"><div class="fill"></div></div>
            <div class="hint">Bezig met tellen…</div>
          </div>

          <details class="control" style="padding: 0; overflow: hidden;">
            <summary style="list-style: none; cursor: pointer; padding: 10px;">Geavanceerde instellingen</summary>
            <div style="padding: 10px; display: grid; gap: 10px;">
              <div class="control">
                <label for="resizeMax">Max breedte voor analyse <span id="resizeMaxVal">650</span> px</label>
                <input id="resizeMax" type="range" min="650" max="650" step="1" value="650" disabled />
              </div>

              <div class="control">
                <label for="blur">Blur <span id="blurVal">9</span></label>
                <input id="blur" type="range" min="1" max="31" step="2" value="9" />
              </div>

              <div class="control">
                <label for="dp">dp (Hough) <span id="dpVal">1.2</span></label>
                <input id="dp" type="range" min="10" max="30" step="1" value="12" />
              </div>

              <div class="control">
                <label for="minDist">Min afstand tussen munten <span id="minDistVal">30</span></label>
                <input id="minDist" type="range" min="5" max="140" step="1" value="30" />
              </div>

              <div class="control">
                <label for="param1">Edge threshold (param1) <span id="param1Val">140</span></label>
                <input id="param1" type="range" min="30" max="250" step="1" value="140" />
              </div>

              <div class="control">
                <label for="param2">Detectie gevoeligheid (param2) <span id="param2Val">38</span></label>
                <input id="param2" type="range" min="10" max="120" step="1" value="38" />
              </div>

              <div class="control">
                <label for="minRadius">Min radius <span id="minRadiusVal">35</span></label>
                <input id="minRadius" type="range" min="0" max="200" step="1" value="35" />
              </div>

              <div class="control">
                <label for="maxRadius">Max radius <span id="maxRadiusVal">160</span></label>
                <input id="maxRadius" type="range" min="0" max="400" step="1" value="160" />
              </div>
            </div>
          </details>

          <div class="status">
            <div class="pill"><span id="cvDot" class="dot"></span><span id="cvStatus">OpenCV laden…</span></div>
            <div style="margin-top:10px;">
              <strong>Gevonden munten:</strong> <span id="count">0</span>
            </div>
            <div id="msg" class="hint" style="margin-top:8px;"></div>
          </div>
        </div>
      </section>

      <section class="card">
        <h2>Resultaat</h2>
        <div class="canvasWrap">
          <canvas id="canvas"></canvas>
          <div class="hint">
            Tips: gebruik een foto met goed contrast, munten zo min mogelijk overlappend, en liefst zonder zware reflecties. Als er te veel/te weinig wordt gevonden: pas vooral <strong>param2</strong>, <strong>minDist</strong> en <strong>min/max radius</strong> aan.
          </div>
        </div>
      </section>
    </div>
  </div>

  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <script defer src="https://unpkg.com/heic2any/dist/heic2any.min.js" type="text/javascript"></script>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(() => {});
      });
    }

    const els = {
      fileInput: document.getElementById('fileInput'),
      whiteMode: document.getElementById('whiteMode'),
      canvas: document.getElementById('canvas'),
      detectBtn: document.getElementById('detectBtn'),
      editBtn: document.getElementById('editBtn'),
      resetBtn: document.getElementById('resetBtn'),
      downloadBtn: document.getElementById('downloadBtn'),
      count: document.getElementById('count'),
      msg: document.getElementById('msg'),
      cvDot: document.getElementById('cvDot'),
      cvStatus: document.getElementById('cvStatus'),
      progressWrap: document.getElementById('progressWrap'),

      resizeMax: document.getElementById('resizeMax'),
      blur: document.getElementById('blur'),
      dp: document.getElementById('dp'),
      minDist: document.getElementById('minDist'),
      param1: document.getElementById('param1'),
      param2: document.getElementById('param2'),
      minRadius: document.getElementById('minRadius'),
      maxRadius: document.getElementById('maxRadius'),

      resizeMaxVal: document.getElementById('resizeMaxVal'),
      blurVal: document.getElementById('blurVal'),
      dpVal: document.getElementById('dpVal'),
      minDistVal: document.getElementById('minDistVal'),
      param1Val: document.getElementById('param1Val'),
      param2Val: document.getElementById('param2Val'),
      minRadiusVal: document.getElementById('minRadiusVal'),
      maxRadiusVal: document.getElementById('maxRadiusVal'),
    };

    const ctx = els.canvas.getContext('2d', { willReadFrequently: true });
    let sourceImg = new Image();
    let imageLoaded = false;
    let opencvReady = false;
    let busy = false;
    let editMode = false;
    let circlesState = [];

    function setCvStatus(kind, text) {
      els.cvDot.classList.remove('ok', 'busy', 'bad');
      if (kind === 'ok') els.cvDot.classList.add('ok');
      if (kind === 'busy') els.cvDot.classList.add('busy');
      if (kind === 'bad') els.cvDot.classList.add('bad');
      els.cvStatus.textContent = text;
    }

    function setBusy(isBusy) {
      busy = isBusy;
      els.detectBtn.disabled = !opencvReady || !imageLoaded || busy;
      els.resetBtn.disabled = !imageLoaded || busy;
      els.downloadBtn.disabled = !imageLoaded || busy;
      if (els.progressWrap) {
        els.progressWrap.classList.toggle('hidden', !isBusy);
      }
      if (isBusy) setCvStatus('busy', 'Bezig met detecteren…');
      else setCvStatus(opencvReady ? 'ok' : 'busy', opencvReady ? 'OpenCV klaar' : 'OpenCV laden…');
    }

    function updateLabels() {
      els.resizeMaxVal.textContent = String(els.resizeMax.value);
      els.blurVal.textContent = String(els.blur.value);
      els.dpVal.textContent = (Number(els.dp.value) / 10).toFixed(1);
      els.minDistVal.textContent = String(els.minDist.value);
      els.param1Val.textContent = String(els.param1.value);
      els.param2Val.textContent = String(els.param2.value);
      els.minRadiusVal.textContent = String(els.minRadius.value);
      els.maxRadiusVal.textContent = String(els.maxRadius.value);
    }

    function resetOutput() {
      els.count.textContent = '0';
      els.msg.textContent = '';
      circlesState = [];
      if (imageLoaded) {
        drawImageToCanvas();
      } else {
        ctx.clearRect(0, 0, els.canvas.width, els.canvas.height);
      }
    }

    function render() {
      if (!imageLoaded) return;
      drawImageToCanvas();
      drawCircles(circlesState);
      els.count.textContent = String(circlesState.length);
    }

    function drawImageToCanvas() {
      const maxW = 650;
      const scale = Math.min(1, maxW / sourceImg.naturalWidth);
      const w = Math.max(1, Math.round(sourceImg.naturalWidth * scale));
      const h = Math.max(1, Math.round(sourceImg.naturalHeight * scale));
      els.canvas.width = w;
      els.canvas.height = h;
      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(sourceImg, 0, 0, w, h);
    }

    function getParams() {
      const blurK = Number(els.blur.value);
      const dp = Number(els.dp.value) / 10;
      const minDist = Number(els.minDist.value);
      const param1 = Number(els.param1.value);
      const param2 = Number(els.param2.value);
      const minRadius = Number(els.minRadius.value);
      const maxRadius = Number(els.maxRadius.value);

      return { blurK, dp, minDist, param1, param2, minRadius, maxRadius };
    }

    function drawCircles(circles) {
      if (!circles || circles.length === 0) return;

      ctx.save();
      ctx.lineWidth = Math.max(2, Math.round(Math.min(els.canvas.width, els.canvas.height) / 350));
      ctx.strokeStyle = 'rgba(255, 230, 109, 0.95)';
      ctx.fillStyle = 'rgba(122, 162, 255, 0.95)';

      const fontSize = Math.max(12, Math.round(Math.min(els.canvas.width, els.canvas.height) / 40));
      ctx.font = `600 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = 'middle';

      for (let i = 0; i < circles.length; i++) {
        const c = circles[i];
        const n = i + 1;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(c.x, c.y, Math.max(2, ctx.lineWidth + 1), 0, Math.PI * 2);
        ctx.fill();

        const label = String(n);
        const padX = Math.max(6, Math.round(fontSize * 0.35));
        const padY = Math.max(4, Math.round(fontSize * 0.22));
        const metrics = ctx.measureText(label);
        const boxW = metrics.width + padX * 2;
        const boxH = fontSize + padY * 2;
        const bx = Math.max(0, Math.min(els.canvas.width - boxW, c.x - boxW / 2));
        const by = Math.max(0, Math.min(els.canvas.height - boxH, c.y - boxH / 2));

        ctx.fillStyle = 'rgba(11, 18, 32, 0.80)';
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.22)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(bx, by, boxW, boxH, Math.max(6, Math.round(boxH / 3)));
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
        ctx.fillText(label, bx + padX, by + boxH / 2);

        ctx.strokeStyle = 'rgba(255, 230, 109, 0.95)';
        ctx.lineWidth = Math.max(2, Math.round(Math.min(els.canvas.width, els.canvas.height) / 350));
        ctx.fillStyle = 'rgba(122, 162, 255, 0.95)';
      }

      ctx.restore();
    }

    function setEditMode(on) {
      editMode = !!on;
      if (els.editBtn) {
        els.editBtn.textContent = editMode ? 'Bewerken: aan' : 'Bewerken: uit';
        els.editBtn.classList.toggle('active', editMode);
      }
      els.msg.textContent = editMode ? 'Bewerken aan: tik op een cirkel om te verwijderen. Tik op lege plek om toe te voegen.' : '';
    }

    function getCanvasPointFromEvent(ev) {
      const rect = els.canvas.getBoundingClientRect();
      const x = (ev.clientX - rect.left) * (els.canvas.width / rect.width);
      const y = (ev.clientY - rect.top) * (els.canvas.height / rect.height);
      return { x, y };
    }

    function medianRadius() {
      if (!circlesState || circlesState.length === 0) return Math.max(20, Number(els.minRadius && els.minRadius.value ? els.minRadius.value : 30));
      const rs = circlesState.map((c) => c.r).filter((r) => Number.isFinite(r)).sort((a, b) => a - b);
      return rs[Math.floor(rs.length / 2)] || Math.max(20, Number(els.minRadius && els.minRadius.value ? els.minRadius.value : 30));
    }

    function findHitCircleIndex(pt) {
      const tol = Math.max(10, Math.min(22, medianRadius() * 0.25));
      for (let i = 0; i < circlesState.length; i++) {
        const c = circlesState[i];
        const dx = pt.x - c.x;
        const dy = pt.y - c.y;
        const d = Math.hypot(dx, dy);
        if (d <= c.r + tol) return i;
      }
      return -1;
    }

    function nextFrame() {
      return new Promise((resolve) => requestAnimationFrame(() => resolve()))
    }

    function dedupeCircles(circles) {
      if (!circles || circles.length <= 1) return circles || [];
      const sorted = [...circles].sort((a, b) => b.r - a.r);
      const kept = [];

      for (const c of sorted) {
        let ok = true;
        for (const k of kept) {
          const dx = c.x - k.x;
          const dy = c.y - k.y;
          const d = Math.hypot(dx, dy);
          const rMin = Math.min(c.r, k.r);
          const rMax = Math.max(c.r, k.r);
          const similarSize = (rMax / Math.max(1, rMin)) < 1.25;
          const veryClose = d < (0.35 * rMin);
          if (similarSize && veryClose) {
            ok = false;
            break;
          }
        }
        if (ok) kept.push(c);
      }

      return kept.sort((a, b) => (a.y - b.y) || (a.x - b.x));
    }

    function edgeRingFilter(circles, edges, opts) {
      if (!circles || circles.length === 0) return [];
      const width = edges.cols;
      const height = edges.rows;

      const sampleCount = opts && opts.sampleCount ? opts.sampleCount : 44;
      const minRatio = opts && opts.minRatio ? opts.minRatio : 0.18;
      const minHits = opts && opts.minHits ? opts.minHits : 8;
      const ringInner = opts && opts.ringInner ? opts.ringInner : 0.92;
      const ringOuter = opts && opts.ringOuter ? opts.ringOuter : 1.06;

      function isEdgeAt(x, y) {
        const xi = x | 0;
        const yi = y | 0;
        if (xi < 0 || yi < 0 || xi >= width || yi >= height) return false;
        return edges.data[yi * width + xi] > 0;
      }

      const out = [];
      for (const c of circles) {
        const cx = c.x;
        const cy = c.y;
        const r = c.r;

        if (!Number.isFinite(cx) || !Number.isFinite(cy) || !Number.isFinite(r) || r <= 0) continue;
        if (r > Math.min(width, height) * 0.49) continue;

        let hits = 0;
        for (let i = 0; i < sampleCount; i++) {
          const a = (i / sampleCount) * Math.PI * 2;
          const ca = Math.cos(a);
          const sa = Math.sin(a);

          const x1 = cx + ca * r * ringInner;
          const y1 = cy + sa * r * ringInner;
          const x2 = cx + ca * r * ringOuter;
          const y2 = cy + sa * r * ringOuter;

          if (isEdgeAt(x1, y1) || isEdgeAt(x2, y2)) hits++;
        }

        const ratio = hits / sampleCount;
        if (hits >= minHits && ratio >= minRatio) {
          out.push(c);
        }
      }

      return out;
    }

    function buildNonWhiteMask(srcRgba) {
      const rgb = new cv.Mat();
      cv.cvtColor(srcRgba, rgb, cv.COLOR_RGBA2RGB);

      const hsv = new cv.Mat();
      cv.cvtColor(rgb, hsv, cv.COLOR_RGB2HSV);

      const channels = new cv.MatVector();
      cv.split(hsv, channels);
      const s = channels.get(1);
      const v = channels.get(2);

      const sMask = new cv.Mat();
      const vMask = new cv.Mat();
      cv.threshold(s, sMask, 35, 255, cv.THRESH_BINARY);
      cv.threshold(v, vMask, 235, 255, cv.THRESH_BINARY_INV);

      const mask = new cv.Mat();
      cv.bitwise_or(sMask, vMask, mask);

      const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5, 5));
      cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
      cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernel);

      rgb.delete();
      hsv.delete();
      s.delete();
      v.delete();
      channels.delete();
      sMask.delete();
      vMask.delete();
      kernel.delete();

      return mask;
    }

    function maskOverlapFilter(circles, mask) {
      if (!circles || circles.length === 0) return [];
      if (!mask || mask.empty()) return circles;

      const w = mask.cols;
      const h = mask.rows;
      const data = mask.data;

      function sampleMask(x, y) {
        const xi = x | 0;
        const yi = y | 0;
        if (xi < 0 || yi < 0 || xi >= w || yi >= h) return 0;
        return data[yi * w + xi] > 0 ? 1 : 0;
      }

      const out = [];
      for (const c of circles) {
        const samples = 40;
        let hits = 0;
        for (let i = 0; i < samples; i++) {
          const a = (i / samples) * Math.PI * 2;
          const rx = c.x + Math.cos(a) * c.r * 0.55;
          const ry = c.y + Math.sin(a) * c.r * 0.55;
          hits += sampleMask(rx, ry);
        }
        const ratio = hits / samples;
        if (ratio >= 0.05) out.push(c);
      }
      return out;
    }

    function findContourCircles(gray, minRadius, maxRadius) {
      const bin = new cv.Mat();
      cv.adaptiveThreshold(gray, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 31, 2);

      const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
      const morphed = new cv.Mat();
      cv.morphologyEx(bin, morphed, cv.MORPH_OPEN, kernel);
      cv.morphologyEx(morphed, morphed, cv.MORPH_CLOSE, kernel);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      const circles = [];
      const rMin = Math.max(0, minRadius);
      const rMax = maxRadius > 0 ? maxRadius : Math.min(gray.cols, gray.rows);

      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        const perim = cv.arcLength(cnt, true);
        if (!Number.isFinite(area) || !Number.isFinite(perim) || perim <= 0) {
          cnt.delete();
          continue;
        }

        const circularity = (4 * Math.PI * area) / (perim * perim);
        if (circularity < 0.62) {
          cnt.delete();
          continue;
        }

        const circle = cv.minEnclosingCircle(cnt);
        const x = circle.center.x;
        const y = circle.center.y;
        const r = circle.radius;

        if (r >= rMin && r <= rMax && Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(r)) {
          circles.push({ x, y, r });
        }
        cnt.delete();
      }

      bin.delete();
      kernel.delete();
      morphed.delete();
      contours.delete();
      hierarchy.delete();

      return circles;
    }

    function consensusCircles(houghCircles, contourCircles) {
      if (!houghCircles || houghCircles.length === 0) return [];
      if (!contourCircles || contourCircles.length === 0) return [];

      const used = new Set();
      const out = [];

      for (const h of houghCircles) {
        let bestIdx = -1;
        let bestScore = Infinity;
        for (let i = 0; i < contourCircles.length; i++) {
          if (used.has(i)) continue;
          const c = contourCircles[i];
          const dx = h.x - c.x;
          const dy = h.y - c.y;
          const d = Math.hypot(dx, dy);
          const rMin = Math.min(h.r, c.r);
          const rMax = Math.max(h.r, c.r);
          const rRatio = rMax / Math.max(1, rMin);
          const maxD = Math.max(6, 0.22 * rMin);
          if (d > maxD) continue;
          if (rRatio > 1.35) continue;

          const score = d + (rRatio - 1) * 10;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = i;
          }
        }

        if (bestIdx >= 0) {
          used.add(bestIdx);
          out.push(h);
        }
      }

      return out;
    }

    async function detectCoins() {
      if (!opencvReady || !imageLoaded || busy) return;
      setBusy(true);
      resetOutput();
      setEditMode(false);

      await nextFrame();

      const { blurK, dp, minDist, param1, param2, minRadius, maxRadius } = getParams();

      if (maxRadius > 0 && minRadius > maxRadius) {
        els.msg.innerHTML = '<span class="err">Min radius is groter dan max radius.</span>';
        setBusy(false);
        return;
      }

      try {
        const src = cv.imread(els.canvas);
        const gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        const blurred = new cv.Mat();
        const k = Math.max(1, blurK | 1);
        cv.GaussianBlur(gray, blurred, new cv.Size(k, k), 0, 0, cv.BORDER_DEFAULT);

        const edges = new cv.Mat();
        const t2 = Math.max(40, Math.min(260, param1));
        const t1 = Math.max(20, Math.round(t2 * 0.5));
        cv.Canny(blurred, edges, t1, t2);

        const circles = new cv.Mat();
        cv.HoughCircles(
          blurred,
          circles,
          cv.HOUGH_GRADIENT,
          dp,
          minDist,
          param1,
          param2,
          minRadius,
          maxRadius
        );

        let out = [];
        if (!circles.empty()) {
          for (let i = 0; i < circles.cols; i++) {
            const x = circles.data32F[i * 3];
            const y = circles.data32F[i * 3 + 1];
            const r = circles.data32F[i * 3 + 2];
            if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(r)) {
              out.push({ x, y, r });
            }
          }
        }

        out = out.filter((c) => c.r >= Math.max(0, minRadius));
        out = edgeRingFilter(out, edges, {
          sampleCount: 48,
          minRatio: 0.17,
          minHits: 8,
        });
        out = dedupeCircles(out);

        const contourOut = dedupeCircles(findContourCircles(blurred, minRadius, maxRadius));
        out = consensusCircles(out, contourOut);
        if (els.whiteMode && els.whiteMode.checked) {
          const mask = buildNonWhiteMask(src);
          out = maskOverlapFilter(out, mask);
          mask.delete();
        }
        out = dedupeCircles(out);

        src.delete();
        gray.delete();
        blurred.delete();
        edges.delete();
        circles.delete();

        circlesState = out;
        render();
        if (out.length === 0) {
          els.msg.textContent = 'Geen munten gevonden met deze instellingen. Probeer param2 lager, of radius/minDist aanpassen.';
        } else {
          els.msg.textContent = 'Klaar.';
        }
      } catch (e) {
        els.msg.innerHTML = '<span class="err">Fout tijdens detectie: </span>' + String(e && e.message ? e.message : e);
      } finally {
        setBusy(false);
      }
    }

    function downloadCanvas() {
      if (!imageLoaded) return;
      const link = document.createElement('a');
      link.download = 'munten-resultaat.png';
      link.href = els.canvas.toDataURL('image/png');
      link.click();
    }

    function isHeicFile(file) {
      const name = String(file && file.name ? file.name : '').toLowerCase();
      const type = String(file && file.type ? file.type : '').toLowerCase();
      return type.includes('heic') || type.includes('heif') || name.endsWith('.heic') || name.endsWith('.heif');
    }

    async function toDisplayableBlob(file) {
      if (!file) return null;

      if (!isHeicFile(file)) {
        return file;
      }

      if (typeof heic2any !== 'function') {
        throw new Error('HEIC wordt nog niet ondersteund (converter kon niet laden).');
      }

      const out = await heic2any({
        blob: file,
        toType: 'image/jpeg',
        quality: 0.92,
      });

      if (out instanceof Blob) return out;
      if (Array.isArray(out) && out[0] instanceof Blob) return out[0];
      throw new Error('HEIC conversie mislukt.');
    }

    async function setImageFromFile(file) {
      if (!file) return;

      setBusy(true);
      els.msg.textContent = '';
      imageLoaded = false;
      els.detectBtn.disabled = true;
      els.resetBtn.disabled = true;
      els.downloadBtn.disabled = true;

      let url = '';
      try {
        const blob = await toDisplayableBlob(file);
        url = URL.createObjectURL(blob);
        sourceImg = new Image();
        sourceImg.onload = () => {
          URL.revokeObjectURL(url);
          imageLoaded = true;
          drawImageToCanvas();
          resetOutput();
          els.detectBtn.disabled = !opencvReady;
          if (els.editBtn) els.editBtn.disabled = false;
          els.resetBtn.disabled = false;
          els.downloadBtn.disabled = false;
          setBusy(false);
        };
        sourceImg.onerror = () => {
          URL.revokeObjectURL(url);
          imageLoaded = false;
          els.msg.innerHTML = '<span class="err">Kon deze afbeelding niet laden.</span> Als dit een HEIC foto is: probeer opnieuw na een paar seconden (converter laden), of zet je iPhone camera op “Meest compatibel”.';
          setBusy(false);
        };
        sourceImg.src = url;
      } catch (e) {
        if (url) URL.revokeObjectURL(url);
        imageLoaded = false;
        els.msg.innerHTML = '<span class="err">Upload probleem: </span>' + String(e && e.message ? e.message : e);
        setBusy(false);
      }
    }

    function wireEvents() {
      updateLabels();
      for (const id of ['resizeMax','blur','dp','minDist','param1','param2','minRadius','maxRadius']) {
        els[id].addEventListener('input', () => {
          updateLabels();
          if (imageLoaded) {
            render();
          }
        });
      }

      els.fileInput.addEventListener('change', (ev) => {
        const file = ev.target.files && ev.target.files[0];
        setImageFromFile(file);
      });

      els.detectBtn.addEventListener('click', detectCoins);
      if (els.editBtn) {
        els.editBtn.addEventListener('click', () => {
          if (!imageLoaded || busy) return;
          setEditMode(!editMode);
        });
      }
      els.resetBtn.addEventListener('click', resetOutput);
      els.downloadBtn.addEventListener('click', downloadCanvas);

      els.canvas.addEventListener('pointerdown', (ev) => {
        if (!editMode || busy || !imageLoaded) return;
        ev.preventDefault();
        const pt = getCanvasPointFromEvent(ev);
        const idx = findHitCircleIndex(pt);
        if (idx >= 0) {
          circlesState.splice(idx, 1);
        } else {
          const r = medianRadius();
          circlesState.push({ x: pt.x, y: pt.y, r });
        }
        circlesState = dedupeCircles(circlesState);
        render();
      }, { passive: false });
    }

    wireEvents();

    (function waitForOpenCV() {
      const start = Date.now();
      const maxWaitMs = 30000;

      function tick() {
        const elapsed = Date.now() - start;
        if (typeof cv !== 'undefined' && cv) {
          if (typeof cv.imread === 'function' && typeof cv.Mat === 'function') {
            opencvReady = true;
            setCvStatus('ok', 'OpenCV klaar');
            els.detectBtn.disabled = !imageLoaded || busy;
            return;
          }
          if (typeof cv.onRuntimeInitialized === 'function') {
            const prev = cv.onRuntimeInitialized;
            cv.onRuntimeInitialized = () => {
              try { prev(); } catch (_) {}
              opencvReady = true;
              setCvStatus('ok', 'OpenCV klaar');
              els.detectBtn.disabled = !imageLoaded || busy;
            };
          }
        }
        if (elapsed > maxWaitMs) {
          setCvStatus('bad', 'OpenCV laden mislukt');
          els.msg.innerHTML = '<span class="err">OpenCV.js kon niet geladen worden.</span> Controleer je internetverbinding of blokkers (adblock/firewall).';
          return;
        }
        setCvStatus('busy', 'OpenCV laden…');
        setTimeout(tick, 150);
      }

      tick();
    })();
  </script>
</body>
</html>
